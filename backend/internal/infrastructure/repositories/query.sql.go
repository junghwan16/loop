// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package repositories

import (
	"context"
	"database/sql"
)

const findAttemptByID = `-- name: FindAttemptByID :one
SELECT id, user_id, sentence_id, user_input, created_at, evaluation FROM attempts WHERE id = ?
`

func (q *Queries) FindAttemptByID(ctx context.Context, id string) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, findAttemptByID, id)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SentenceID,
		&i.UserInput,
		&i.CreatedAt,
		&i.Evaluation,
	)
	return i, err
}

const findAttemptByUserAndSentence = `-- name: FindAttemptByUserAndSentence :one
SELECT id, user_id, sentence_id, user_input, created_at, evaluation FROM attempts WHERE user_id = ? AND sentence_id = ?
`

type FindAttemptByUserAndSentenceParams struct {
	UserID     sql.NullString `json:"user_id"`
	SentenceID sql.NullString `json:"sentence_id"`
}

func (q *Queries) FindAttemptByUserAndSentence(ctx context.Context, arg FindAttemptByUserAndSentenceParams) (Attempt, error) {
	row := q.db.QueryRowContext(ctx, findAttemptByUserAndSentence, arg.UserID, arg.SentenceID)
	var i Attempt
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SentenceID,
		&i.UserInput,
		&i.CreatedAt,
		&i.Evaluation,
	)
	return i, err
}

const findLearnerProfileByUserID = `-- name: FindLearnerProfileByUserID :one
SELECT user_id, theta, cefr_level, vocab_map, grammar_map, pragmatics_map FROM learner_profiles WHERE user_id = ?
`

func (q *Queries) FindLearnerProfileByUserID(ctx context.Context, userID string) (LearnerProfile, error) {
	row := q.db.QueryRowContext(ctx, findLearnerProfileByUserID, userID)
	var i LearnerProfile
	err := row.Scan(
		&i.UserID,
		&i.Theta,
		&i.CefrLevel,
		&i.VocabMap,
		&i.GrammarMap,
		&i.PragmaticsMap,
	)
	return i, err
}

const findNextSentenceForUser = `-- name: FindNextSentenceForUser :one
SELECT id, text_native, text_target, cefr_level, topic, tags
FROM sentences
WHERE
    cefr_level = ?
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) FindNextSentenceForUser(ctx context.Context, cefrLevel sql.NullString) (Sentence, error) {
	row := q.db.QueryRowContext(ctx, findNextSentenceForUser, cefrLevel)
	var i Sentence
	err := row.Scan(
		&i.ID,
		&i.TextNative,
		&i.TextTarget,
		&i.CefrLevel,
		&i.Topic,
		&i.Tags,
	)
	return i, err
}

const findSentenceByID = `-- name: FindSentenceByID :one
SELECT id, text_native, text_target, cefr_level, topic, tags FROM sentences WHERE id = ?
`

func (q *Queries) FindSentenceByID(ctx context.Context, id string) (Sentence, error) {
	row := q.db.QueryRowContext(ctx, findSentenceByID, id)
	var i Sentence
	err := row.Scan(
		&i.ID,
		&i.TextNative,
		&i.TextTarget,
		&i.CefrLevel,
		&i.Topic,
		&i.Tags,
	)
	return i, err
}

const findUserByEmail = `-- name: FindUserByEmail :one
SELECT id, email, native_lang, target_lang FROM users WHERE email = ?
`

func (q *Queries) FindUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.NativeLang,
		&i.TargetLang,
	)
	return i, err
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, email, native_lang, target_lang FROM users WHERE id = ?
`

func (q *Queries) FindUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.NativeLang,
		&i.TargetLang,
	)
	return i, err
}

const saveAttempt = `-- name: SaveAttempt :exec
INSERT INTO
    attempts (
        id,
        user_id,
        sentence_id,
        user_input,
        evaluation
    )
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (id) DO
UPDATE
SET
    user_input = excluded.user_input,
    evaluation = excluded.evaluation
`

type SaveAttemptParams struct {
	ID         string         `json:"id"`
	UserID     sql.NullString `json:"user_id"`
	SentenceID sql.NullString `json:"sentence_id"`
	UserInput  string         `json:"user_input"`
	Evaluation sql.NullString `json:"evaluation"`
}

// Attempt queries
func (q *Queries) SaveAttempt(ctx context.Context, arg SaveAttemptParams) error {
	_, err := q.db.ExecContext(ctx, saveAttempt,
		arg.ID,
		arg.UserID,
		arg.SentenceID,
		arg.UserInput,
		arg.Evaluation,
	)
	return err
}

const saveLearnerProfile = `-- name: SaveLearnerProfile :exec
INSERT INTO
    learner_profiles (
        user_id,
        theta,
        cefr_level,
        vocab_map,
        grammar_map,
        pragmatics_map
    )
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (user_id) DO
UPDATE
SET
    theta = excluded.theta,
    cefr_level = excluded.cefr_level,
    vocab_map = excluded.vocab_map,
    grammar_map = excluded.grammar_map,
    pragmatics_map = excluded.pragmatics_map
`

type SaveLearnerProfileParams struct {
	UserID        string          `json:"user_id"`
	Theta         sql.NullFloat64 `json:"theta"`
	CefrLevel     sql.NullString  `json:"cefr_level"`
	VocabMap      sql.NullString  `json:"vocab_map"`
	GrammarMap    sql.NullString  `json:"grammar_map"`
	PragmaticsMap sql.NullString  `json:"pragmatics_map"`
}

// LearnerProfile queries
func (q *Queries) SaveLearnerProfile(ctx context.Context, arg SaveLearnerProfileParams) error {
	_, err := q.db.ExecContext(ctx, saveLearnerProfile,
		arg.UserID,
		arg.Theta,
		arg.CefrLevel,
		arg.VocabMap,
		arg.GrammarMap,
		arg.PragmaticsMap,
	)
	return err
}

const saveSentence = `-- name: SaveSentence :exec
INSERT INTO
    sentences (
        id,
        text_native,
        text_target,
        cefr_level,
        topic,
        tags
    )
VALUES (?, ?, ?, ?, ?, ?)
ON CONFLICT (id) DO
UPDATE
SET
    text_native = excluded.text_native,
    text_target = excluded.text_target,
    cefr_level = excluded.cefr_level,
    topic = excluded.topic,
    tags = excluded.tags
`

type SaveSentenceParams struct {
	ID         string         `json:"id"`
	TextNative string         `json:"text_native"`
	TextTarget sql.NullString `json:"text_target"`
	CefrLevel  sql.NullString `json:"cefr_level"`
	Topic      sql.NullString `json:"topic"`
	Tags       sql.NullString `json:"tags"`
}

// Sentence queries
func (q *Queries) SaveSentence(ctx context.Context, arg SaveSentenceParams) error {
	_, err := q.db.ExecContext(ctx, saveSentence,
		arg.ID,
		arg.TextNative,
		arg.TextTarget,
		arg.CefrLevel,
		arg.Topic,
		arg.Tags,
	)
	return err
}

const saveUser = `-- name: SaveUser :exec
INSERT INTO
    users (
        id,
        email,
        native_lang,
        target_lang
    )
VALUES (?, ?, ?, ?)
ON CONFLICT (id) DO
UPDATE
SET
    email = excluded.email,
    native_lang = excluded.native_lang,
    target_lang = excluded.target_lang
`

type SaveUserParams struct {
	ID         string `json:"id"`
	Email      string `json:"email"`
	NativeLang string `json:"native_lang"`
	TargetLang string `json:"target_lang"`
}

// User queries
func (q *Queries) SaveUser(ctx context.Context, arg SaveUserParams) error {
	_, err := q.db.ExecContext(ctx, saveUser,
		arg.ID,
		arg.Email,
		arg.NativeLang,
		arg.TargetLang,
	)
	return err
}
